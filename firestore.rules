rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    /* ===== Helper Functions ===== */
    function signedIn() {
      return request.auth != null;
    }
    
    function isAdmin() {
      return signedIn() &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }
    
    // Check if user is the owner of a resource (for metadata with createdBy field)
    function isOwner() {
      return signedIn() && resource.data.createdBy == request.auth.uid;
    }
    
    // Check if user is creator role
    function isCreator() {
      return signedIn() &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'creator';
    }
    
    // Get quiz document for subcollection access checks
    function quizDoc(quizId) {
      return get(/databases/$(database)/documents/quizzes/$(quizId));
    }
    
    // Check if user has unlocked password-protected quiz
    function hasAccess(quizId) {
      return exists(/databases/$(database)/documents/quizzes/$(quizId)/access/$(request.auth.uid));
    }
    
    // Check if quiz is approved (for result submission)
    function isQuizApproved(quizId) {
      return quizDoc(quizId).data.status == 'approved';
    }

    /* ===== Multiplayer Validation Functions ===== */
    // Validate room name
    function validateRoomName(name) {
      return name is string && 
             name.size() >= 3 && 
             name.size() <= 50 &&
             !name.matches('.*[<>\"\'&].*'); // No HTML special chars
    }
    
    // Validate max players
    function validateMaxPlayers(count) {
      return count is int && 
             count >= 2 && 
             count <= 20;
    }
    
    // Validate password length (for hashed passwords)
    function validatePassword(pwd) {
      return pwd is string && 
             pwd.size() >= 64 && // SHA256 hash length
             pwd.size() <= 128;
    }
    
    // Check if user is host of room
    function isHost(roomId) {
      return signedIn() &&
        get(/databases/$(database)/documents/multiplayer_rooms/$(roomId)).data.hostId == request.auth.uid;
    }
    
    // ⚠️ DEPRECATED: Players are now stored in RTDB only
    // Keep for backward compatibility with old data
    function isPlayer(roomId) {
      return signedIn() &&
        exists(/databases/$(database)/documents/multiplayer_rooms/$(roomId)/players/$(request.auth.uid));
    }
    
    // Validate room data structure
    function validateRoomData() {
      let data = request.resource.data;
      return data.name is string &&
             validateRoomName(data.name) &&
             data.maxPlayers is int &&
             validateMaxPlayers(data.maxPlayers) &&
             data.quizId is string &&
             data.quiz is map && // Must be object
             data.quiz.id == data.quizId && // Consistency check
             data.quiz.questions is list && // Must have questions
             data.quiz.questions.size() > 0 && // At least 1 question
             data.hostId == request.auth.uid &&
             data.status in ['waiting', 'starting', 'playing', 'finished'] &&
             (!('password' in data) || validatePassword(data.password));
    }
    
    // Validate player data structure
    function validatePlayerData() {
      let data = request.resource.data;
      return data.name is string &&
             data.name.size() >= 1 &&
             data.name.size() <= 30 &&
             data.score is int &&
             data.score >= 0;
    }
    
    // Validate message data structure
    function validateMessageData() {
      let data = request.resource.data;
      return data.message is string &&
             data.message.size() >= 1 &&
             data.message.size() <= 500 &&
             data.userId == request.auth.uid;
    }
    
    /* ===== Users Collection ===== */
    match /users/{userId} {
      // Allow all authenticated users to read user profiles (leaderboard, admin, etc.)
      allow read: if signedIn();
      
      // Users can write their own document; admins can write any
      allow write: if signedIn() && (request.auth.uid == userId || isAdmin());
      
      // Notifications subcollection
      match /notifications/{notificationId} {
        // Users can read their own notifications; admins can read all
        allow read: if signedIn() && (request.auth.uid == userId || isAdmin());
        // System and admins can write notifications to any user
        allow write: if signedIn() && (
          request.auth.uid == userId || 
          isAdmin() || 
          request.resource.data.senderId == 'system'
        );
      }
    }
    
    /* ===== Multiplayer Rooms (SEPARATE FROM QUIZ DATA) =====
       Collection: multiplayer_rooms/{roomId}
       Dữ liệu multiplayer hoàn toàn tách biệt với quiz data
       Chỉ lấy thông tin quiz để hiển thị, không ghi vào quiz collection
    */
    match /multiplayer_rooms/{roomId} {
      // Allow ALL authenticated users to read any room (for joining and viewing)
      allow read: if signedIn();
      allow list: if signedIn();
      
      // Allow authenticated users to create new rooms - RELAXED validation for quiz field
      allow create: if signedIn() && 
                      request.resource.data.name is string &&
                      validateRoomName(request.resource.data.name) &&
                      request.resource.data.maxPlayers is int &&
                      validateMaxPlayers(request.resource.data.maxPlayers) &&
                      request.resource.data.quizId is string &&
                      request.resource.data.hostId == request.auth.uid &&
                      request.resource.data.status in ['waiting', 'starting', 'playing', 'finished'];
      
      // Allow host and players to update room (more permissive for multiplayer flow)
      allow update: if signedIn() && (
        isHost(roomId) ||
        isPlayer(roomId) ||
        // Allow game state updates
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'currentQuestion', 'questionStartTime', 'startedAt', 'finishedAt'])
      );
      
      // Only host can delete room
      allow delete: if signedIn() && isHost(roomId);
      
      /* ===== Players Subcollection (DEPRECATED) =====
         ⚠️ DEPRECATED: Players are now stored in RTDB only
         Keeping rules for backward compatibility with old data
         NO NEW WRITES - only read existing data
      */
      match /players/{playerId} {
        // Allow reading existing player data
        allow read: if signedIn();
        // ❌ NO NEW WRITES - players are in RTDB now
        allow create, update, delete: if false;
      }
      
      /* ===== Messages Subcollection (DEPRECATED) =====
         ⚠️ DEPRECATED: Chat messages are now in RTDB only
         Path: rooms/{roomId}/chat/messages
         NO NEW WRITES - only read existing data for history
      */
      match /messages/{messageId} {
        // Allow reading existing messages
        allow read: if signedIn();
        // ❌ NO NEW WRITES - messages are in RTDB now
        allow create, update, delete: if false;
      }
      
      // Answers subcollection - READ ONLY for clients (Cloud Functions write)
      match /answers/{questionIndex}/{userId} {
        allow read: if signedIn();
        allow write: if false; // Only Cloud Functions can write answers
      }
      
      // Leaderboard - READ ONLY for clients (Cloud Functions write)
      match /leaderboard/{userId} {
        allow read: if signedIn();
        allow write: if false; // Only Cloud Functions can write leaderboard
      }
    }

    /* ===== Match Histories (GAME RESULTS) =====
       Collection: match_histories/{matchId}
       Lưu trữ kết quả trò chơi sau khi kết thúc
       matchId = roomId (mỗi phòng có 1 document kết quả)
       
       ✅ OPTIMIZED: Thay vì N documents trong submissions, chỉ có 1 document
       Giảm 90%+ Firestore writes cho multiplayer games
    */
    match /match_histories/{matchId} {
      // Any authenticated user can read game history (for leaderboards, statistics)
      allow read: if signedIn();
      
      // Only host can write match history (via endGame())
      // Host is determined by checking they were the hostId of the room
      allow create: if signedIn() &&
        request.resource.data.hostId == request.auth.uid &&
        request.resource.data.roomId == matchId &&
        request.resource.data.leaderboard is list &&
        request.resource.data.finishedAt != null;
      
      // Match history is immutable once created
      allow update, delete: if false;
    }

    /* ===== Multiplayer Submissions (LEGACY - DEPRECATED) =====
       Subcollection: multiplayer_rooms/{roomId}/submissions/{submissionId}
       ⚠️ DEPRECATED: Use match_histories collection instead
       
       Game answers are now stored in RTDB: games/{roomId}/answers
       Final results are saved to: match_histories/{matchId}
       
       NO NEW WRITES - only read existing data for backward compatibility
    */
    match /multiplayer_rooms/{roomId}/submissions/{submissionId} {
      // Allow reading existing submissions
      allow read: if signedIn();
      // ❌ NO NEW WRITES - use match_histories instead
      allow create, update, delete: if false;
    }
    
    /* ===== QUIZZES - NEW ARCHITECTURE =====
       Cấu trúc:
       - quizzes/{quizId}                 : METADATA (title, description, visibility, pwd, stats, status, ...)
       - quizzes/{quizId}/questions/{qid} : NỘI DUNG ĐỀ (câu hỏi, đáp án) - BẢO VỆ
       - quizzes/{quizId}/access/{uid}    : DẤU HIỆU đã mở khóa password
       
       Quy tắc phân quyền theo ROLE và STATUS:
       
       ┌─────────────┬──────────┬──────────┬───────────────────────┐
       │ ROLE        │ DRAFT    │ PENDING  │ APPROVED              │
       ├─────────────┼──────────┼──────────┼───────────────────────┤
       │ Admin       │ ✅ R/W   │ ✅ R/W   │ ✅ R/W                │
       │ Creator     │ ✅ Own   │ ✅ Own   │ ✅ Own (edit request) │
       │ User        │ ❌       │ ❌       │ ✅ Read (public)      │
       └─────────────┴──────────┴──────────┴───────────────────────┘
       
       METADATA ACCESS:
       - draft: Chỉ owner + admin
       - pending: Chỉ owner + admin (đang chờ duyệt)
       - approved: Tất cả user (hiển thị danh sách)
       - rejected: Chỉ owner + admin
       
       QUESTIONS ACCESS:
       - visibility = "public" + approved → Mọi user
       - visibility = "password" + approved + hasAccess(uid) → User đã unlock
       - Owner/Admin → Luôn truy cập (để quản lý)
    */
    match /quizzes/{quizId} {
      
      /* --- READ METADATA (GET/LIST) ---
         Phân quyền theo STATUS:
         - draft/pending/rejected: Chỉ owner hoặc admin
         - approved: Tất cả user đăng nhập
      */
      allow get, list: if signedIn() && (
        // Admin sees all
        isAdmin() ||
        // Owner sees their own quizzes
        resource.data.createdBy == request.auth.uid ||
        // Everyone sees approved quizzes OR quizzes without status field (treat as approved)
        resource.data.status == 'approved' || !('status' in resource.data)
      );
      
      /* --- CREATE QUIZ ---
         Creator và Admin có thể tạo quiz.
         Cho phép tạo với status 'draft' hoặc 'pending'.
      */
      allow create: if signedIn() && (
        isCreator() || isAdmin()
      ) && request.resource.data.status in ['draft', 'pending'];
      
      /* --- UPDATE QUIZ ---
         Owner: Có thể sửa quiz draft/rejected của mình
         Admin: Có thể sửa mọi quiz và thay đổi status
         Special: Mọi user có thể cập nhật stats counters (CHỈ CHO QUIZ APPROVED)
      */
      allow update: if signedIn() && (
        // Admin can update any quiz and change status
        isAdmin() ||
        // Owner can update their draft/rejected quizzes (not approved/pending)
        (resource.data.createdBy == request.auth.uid && 
         resource.data.status in ['draft', 'rejected']) ||
        // Anyone can update stats counters ONLY for APPROVED quizzes
        (resource.data.status == 'approved' &&
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['stats']))
      );
      
      /* --- DELETE QUIZ ---
         Chỉ owner hoặc admin mới được xóa.
      */
      allow delete: if signedIn() && (
        resource.data.createdBy == request.auth.uid || isAdmin()
      );
      
      /* --- ACCESS SUBCOLLECTION ---
         Client ghi /access/{uid} sau khi user nhập password đúng.
         Rules kiểm tra: proofHash client gửi lên === hash trong quizzes/{quizId}.pwd.hash
         
         NOTE: Simplified validation - hash verification happens client-side
      */
      match /access/{uid} {
        // Read: User can read their own access record
        allow read: if signedIn() && request.auth.uid == uid;
        
        // Create: User can create access record for themselves
        // Hash verification is done client-side before calling this
        allow create: if signedIn() && 
          request.auth.uid == uid &&
          request.resource.data.unlockedAt != null;
        
        // No update or delete
        allow update, delete: if false;
      }
      
      /* --- QUESTIONS SUBCOLLECTION (BẢO VỆ NỘI DUNG ĐỀ) ---
         Phân quyền theo STATUS + VISIBILITY:
         
         Điều kiện đọc:
         1. Admin - luôn đọc được (để quản lý)
         2. Owner - luôn đọc được quiz của mình
         3. User thường - chỉ khi:
            - Quiz đã approved VÀ
            - (visibility = "public" HOẶC đã unlock password)
      */
      match /questions/{qid} {
        allow read: if signedIn() && (
          // Admin can read all
          isAdmin() ||
          // Owner can read their own quiz questions (check both createdBy and authorId)
          quizDoc(quizId).data.createdBy == request.auth.uid ||
          quizDoc(quizId).data.authorId == request.auth.uid ||
          // Regular users: only approved + (public OR unlocked OR no visibility field)
          (quizDoc(quizId).data.status == 'approved' && (
            quizDoc(quizId).data.visibility == "public" ||
            !('visibility' in quizDoc(quizId).data) ||
            (
              (quizDoc(quizId).data.visibility == "password" || quizDoc(quizId).data.havePassword == "password") && 
              hasAccess(quizId)
            )
          ))
        );
        
        // WRITE: Chỉ owner hoặc admin
        allow write: if signedIn() && (
          isAdmin() ||
          quizDoc(quizId).data.createdBy == request.auth.uid
        );
      }
    }
    
    /* ===== OTHER COLLECTIONS (keep existing logic) ===== */
    
    // Reviews collection
    match /reviews/{reviewId} {
      allow read: if signedIn();
      allow create: if signedIn() && request.resource.data.userId == request.auth.uid;
      allow update, delete: if signedIn() && resource.data.userId == request.auth.uid;
    }
    
    // System notifications
    match /system_notifications/{notificationId} {
      allow read: if signedIn();
      allow write: if isAdmin();
    }
    
    // User favorites
    match /user_favorites/{userId} {
      allow read, write: if signedIn() && request.auth.uid == userId;
    }
    
    // User quiz activities (tracking views, attempts, etc.)
    match /userQuizActivities/{activityId} {
      allow read: if signedIn();
      allow create, update: if signedIn() && request.resource.data.userId == request.auth.uid;
      allow delete: if signedIn() && resource.data.userId == request.auth.uid;
    }
    
    // Quiz completions (global activity log for tracking quiz completions)
    // Only allow creating completions for APPROVED quizzes
    match /quizCompletions/{completionId} {
      allow read: if signedIn();
      allow create: if signedIn() && 
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.quizId is string &&
        isQuizApproved(request.resource.data.quizId);
      allow update, delete: if signedIn() && resource.data.userId == request.auth.uid;
    }
    
    // Quiz results
    // Only allow creating results for APPROVED quizzes
    // Creator can view their draft/pending quiz but CANNOT save results
    match /quizResults/{resultId} {
      allow read: if signedIn();
      allow create: if signedIn() && 
        request.resource.data.userId == request.auth.uid &&
        request.resource.data.quizId is string &&
        isQuizApproved(request.resource.data.quizId);
      allow update, delete: if signedIn() && resource.data.userId == request.auth.uid;
    }
    
    // Edit requests
    match /editRequests/{requestId} {
      allow read: if signedIn();
      allow create: if signedIn() && request.resource.data.requestedBy == request.auth.uid;
      allow update, delete: if signedIn() && resource.data.requestedBy == request.auth.uid;
    }
    
    // Categories
    match /categories/{categoryId} {
      allow read: if signedIn();
      allow write: if isAdmin();
    }

    // Quiz reviews (public ratings)
    match /quizReviews/{reviewId} {
      allow read: if true;
      allow create: if signedIn() && request.resource.data.userId == request.auth.uid;
      allow update, delete: if signedIn() && resource.data.userId == request.auth.uid;
    }
    
    match /{path=**}/quizReviews/{reviewId} {
      allow read: if true;
      allow create: if signedIn() && request.resource.data.userId == request.auth.uid;
      allow update, delete: if signedIn() && resource.data.userId == request.auth.uid;
    }

    // Per-user notifications
    match /notifications/{notificationId} {
      allow read: if signedIn() && (resource.data.userId == request.auth.uid || isAdmin());
      allow create: if isAdmin();
      allow update, delete: if signedIn() && (resource.data.userId == request.auth.uid || isAdmin());
    }
    
    // Mail collection (Trigger Email extension)
    match /mail/{mailId} {
      allow create: if true;
      allow read, update, delete: if true;
    }
    
    // System collection (for vector index, configs, etc.)
    match /system/{docId} {
      allow read: if signedIn();
      allow write: if isAdmin();
    }
    
    // Default: deny all
    match /{document=**} {
      allow read, write: if false;
    }
  }
}